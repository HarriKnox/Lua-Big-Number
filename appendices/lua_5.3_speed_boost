Note to self: speed boost for this function by using `load`. Specifically, this
function would be rewritten as the following, guarded by an if-statement that
ensures the version is 5.3 and above.

   load("function integermultiplyandaddtosplitlong(x, ab, c) \
      return x * ab + c                                      \
   end")()


Generally, speed boosts for Lua 5.3 work using bitwise operator sigils instead
of function calls. Unfortunately, those sigils are incompatible with Lua 5.2.
The alternative is to use strings and the `load` function. For example:

   function somearbitraryoperation(a, b, c)
      return bitand(a, bitleftshift(bitnot(b), bitor(c, 3)))
   end

becomes

   load("function somearbitraryoperation(a, b, c) \
      return a & (~b << (c | 3))                  \
   end")()

or

   somearbitraryoperation = load("return function(a, b, c) \
      return a & (~b << (c | 3))                           \
   end")()


The string keeps the 5.2 interpreter from erroring and the `load` allows the
5.3 interpreter to understand and compile it. Because the `load` function
returns an executable chunk without executing it you need to call it afterward.
Also, quotes don't carry across newlines so I escaped the newlines with the
backslashes. Also also, I prefer the first option because it produces a named
chunk and not an anonymous chunk assigned to a variable.


The entire function needs to be wrapped in the load string. Simply doing the
following will cause massive functional and loading overhead for each call from
not only calling `load` every time, but also splitting the numerous bitwise
operations across multiple function calls.

   function somearbitraryoperation(a, b, c)
      return load("return function(a, b) return a & b end")()
                 (a, load("return function(a, b) return a << b end")()
                       (load("return function(b) return ~b end")()(b),
                       load("return function(c, d) return c | d end")()
                           (c, 3)))
   end


Also, redefining `bitand`, `bitor`, and the other functions with `load` like
this will, again, cause functional overhead slowdowns.

   bitand = load("return function(a, b) return a & b end")()
   bitor = load("return function(a, b) return a | b end")()
   bitor = load("return function(a) return ~a end")()


These potential changes could also potentially benefit the next function.


